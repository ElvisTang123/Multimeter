# Multimeter

# Abstract
* Created the multimeter’s AC/DC interface on Realterm through USART, USART’s interrupts.
* Calculated input signals’ Vpp and Vrms through sampling its voltages via ADC interrupt.
* Calculated the time interval between each ADC interrupt according to the frequency of the input signal to avoid over-sampling or under-sampling.
* Calculated the frequency of the input signal based on the interval between the two consecutive rising edges of the square wave that is generated by the comparator and the edges are captured by the timer’s interrupts.
* Generated the required square wave by configuring the DAC output value as the average voltage of the input signal and setting it as the reference voltage of the comparator.

# Project Introduction
This is a digital multimeter. It has a DC measure mode and an AC measure mode. It can handle inputs between 0 and 3 volts.  It is capable of reading waves with frequency from 1-1000 Hz. It can read sin, saw-tooth, square, and triangle waves. In DC mode, it reads the voltage level and outputs the corresponding voltage to the terminal. In AC mode it reads the frequency, peak to peak voltage, RMS voltage. When outputting to the terminal the device both displays the values numerically and it displays the values on a series of bar graphs.<br />

# System Specification
It can be seen from the below specifications of the LCD module that the size of the LCD monitor we used for the lockbox is sufficient, and the color contrast is very good. It can not only display the instructions clearly but also have enough space to key in the pins. The power requirement is 3.3V, which is basically very low, so we can use a very small power supply to drive the LCD. <br />

| Parameter | Value | Unit |
| :-----------:  | :-----------: |:-----------: |
| Voltage input| 0-3 | Volts |
| Input type |DC or most types of AC|---|
| Input frequency | 0 or 1-1000 |Hz|
| Freq_out error | +-max(5, 1% of freq) |Hz|
| Voltage our error| +- .25 |V|
| Data points used to read |1000|Points/period|
| Current input necessary | 300 |mA|
| Power source | USB |---|
| User interface | USART Terminal |---|
| Suggested scope probe setting | 1x |---|

# Schematic
<p align="center">
  <img src="Media/Schematic.jpg" alt="" width="70%"/>
</p>

# Software Architecture
## Calculations - Interrupt Period & Max Resolution:<br />

```
ISR_exe = 2.115us (68 clock cycle)
ISR_Start = 0.75us (92-68 = 24 clock cycle)
ISR_Total = 2.865us

Points \ Waveform = (10ms*100khz) \ 2.865us
                  = 1960 points
To make the amount of points can be divided by 3,4,5 
                  => 1800 points
                  
ISR_Total = 10ms / 1800 points = 5.555us
Clock Cycle = 5.55us * 32 Mhz
            = 177.778 clock cycle
            = 178 (CCR1)
```

| ISR Execute Time(ISR_exe) | 2.115us|
| :-----------:  | :-----------: |
| ISR Start Time(ISR_start)| 0.75us |
| ISR Total Time(ISR_tol) |2.865us|
| Maximum Resolution | 1960 samples/ 100Hz_wave |
|Ideal Resolution (Can be divided by 3, 4, and 5)| 1800 samples/ 100Hz_wave |
| Ideal ISR Total Time| 5.555us |
| Ideal Clock Cycle |178 clock cycle|


## Flowchart:<br />
* While Loop:<br />
The structure of the while loop in the main function is made up of three if statements, the three if statements are used to detect which key has been pressed on the keypad. Based on the key being pressed, the function will adjust the global tags of the waveform, frequency, and duty cycles. Through adjusting these tags, the function, TIM2_IRQHandler(), can tell which look-up table it should take the data from and also what frequency and duty cycle should be set.<br />
<p align="center">
  <img src="Media/WhileLoop.jpg" alt="" width="70%"/>
</p>

* Lookup Table:<br />
  * Sin Wave:<br />
We used the built-in sine function in the C programming and scale the range of the sine wave within 0V ~ 3V by the function shown in figure below.<br />
<p align="center">
  <img src="Media/SinWave.jpg" alt="" width="70%"/>
</p>

  * Triangle Wave:<br />
We split the triangle wave in half, the half before the peak of the wave and the half after that. And generate the data with the function shown in figure below.<br />
<p align="center">
  <img src="Media/TriangleWave.jpg" alt="" width="70%"/>
</p>

  * Sawtooth Wave:<br />
The function for the sawtooth wave is the same as the function of the first half of the triangle wave. The only thing we need to change is the slope of the function.<br />
<p align="center">
  <img src="Media/SawtoothWave.jpg" alt="" width="70%"/>
</p>

  * Square Wave:<br />
Because we have to adjust the duty cycle of the square wave, we use two for loops to generate a 9 X samples matrix to store all different duty cycle data.<br />
<p align="center">
  <img src="Media/SquareWave.jpg" alt="" width="70%"/>
</p>

* TIM2_IRQHandler():<br />
Through this function, there will be an interrupt being generated every 178 clock cycles. While this interrupt is generated we will output a single data through the lookup table we generated previously. The function will decide which lookup table to use based on the global tag we have set by the while loop in the main function. The flowchart is shown in figure below.<br />
<p align="center">
  <img src="Media/Interrupt.jpg" alt="" width="70%"/>
</p>

# Demonstration
